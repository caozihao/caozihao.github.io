{"title":"动态规划，最长公共子串，最长公共子序列","slug":"动态规划，最长公共子串，最长公共子序列","date":"2018-12-26T02:22:30.000Z","updated":"2018-12-26T12:56:27.138Z","comments":true,"excerpt":"","content":"<h4 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h4><pre><code>const log = console.log.bind(this);\nconst dynamicProgramming = ()=&gt;{\n    let cell = [];\n//   无小数\n//   数据排列顺序无影响\n    let priceArr = [{3:10},{1:3},{2:9},{2:5},{1:6}];\n    let spaceArr = [0,1,2,3,4,5,6];\n//    有小数\n    // let priceArr = [{3:2000},{4:10000},{1:1500},{2:2500},{1.5:1100},{3.5:9000}];\n    // let spaceArr = [0,0.5,1,1.5,2,2.5,3,3.5,4,4.5,5];\n    for(let i =0; i&lt;priceArr.length;i++){\n        for(let j = 1;j&lt;spaceArr.length;j++){\n            if(!cell[i]){\n              cell[i] = [];\n              cell[i][0] = 0;\n            }\n            let space = Object.keys(priceArr[i])[0]; //当前物件占用的空间\n            let price = priceArr[i][space]; //当前物件的价格\n            let curIndex = parseFloat(spaceArr[j]); //当前物件的索引\n\n            if( i &gt;= 1){ //至少有一行\n                let lessSpace = curIndex - space; //剩余空间\n                let lessPrice = 0; //剩余价值\n                let curItemPirce =  0;\n                log(&apos;............&apos;);\n                log(&apos;lessSpace -&gt;&apos;,lessSpace);\n                if(lessSpace &gt;= 0){\n                    lessPrice = cell[i-1][lessSpace] //剩余空间的价值\n                    curItemPirce = price + lessPrice; // 总共的价值\n                    log(&apos;lessPrice -&gt;&apos;,lessPrice);\n                    log(&apos;curItemPirce -&gt;&apos;,curItemPirce);\n                }\n                let prevItemPirce = cell[i-1][curIndex] //上一个格子的价值\n                cell[i][curIndex] = Math.max(prevItemPirce,curItemPirce);\n            }else{\n                // 大于等于空间的物品才能把价格放进去\n                cell[i][curIndex] = curIndex &gt;= space ? price : 0;\n            }\n\n        }\n    }\n  console.log(&apos;cell -&gt;&apos;,cell);\n}\n</code></pre><h4 id=\"计算最长公共子串\"><a href=\"#计算最长公共子串\" class=\"headerlink\" title=\"计算最长公共子串\"></a>计算最长公共子串</h4><pre><code>const computeTheLongestString = (inputValue,compareValue)=&gt;{\n    let inputArr = inputValue.split(&apos;&apos;);\n    let compareArr = compareValue.split(&apos;&apos;);\n    let result = [];\n    let maxValue = 0;\n    for(let i = 0;i &lt; inputArr.length;i++){\n        for(let j = 0; j&lt;compareArr.length;j++){\n            if(!result[i]){\n                result[i] = [];\n            }\n\n            if(inputArr[i] === compareArr[j]){\n                if(i&gt;0 &amp;&amp; j&gt;0){\n                    result[i][j] = result[i-1][j-1] + 1;\n                }else{\n                    result[i][j] = 1;\n                }\n                maxValue = Math.max(maxValue,result[i][j]);\n            }else{\n                result[i][j] = 0;\n            }\n        }\n    }\n    log(&apos;result -&gt;&apos;,result);\n    log(&apos;maxValue -&gt;&apos;,maxValue);\n}\n\n// computeTheLongestString(&apos;hish&apos;,&apos;fish&apos;);\n// computeTheLongestString(&apos;hish&apos;,&apos;vista&apos;);\n</code></pre><h4 id=\"计算出最长公共子序列\"><a href=\"#计算出最长公共子序列\" class=\"headerlink\" title=\"计算出最长公共子序列\"></a>计算出最长公共子序列</h4><pre><code>const computingTheLongestSubsequence = (inputValue,compareValue)=&gt;{\n    let inputArr = inputValue.split(&apos;&apos;);\n    let compareArr = compareValue.split(&apos;&apos;);\n    let result = [];\n    let maxValue = 0;\n    for(let i = 0;i &lt; inputArr.length;i++){\n        for(let j = 0; j&lt;compareArr.length;j++){\n            if(!result[i]){\n                result[i] = [];\n            }\n\n            if(inputArr[i] === compareArr[j]){\n                if(i&gt;0 &amp;&amp; j&gt;0){\n                    result[i][j] = result[i-1][j-1] + 1;\n                }else{\n                    result[i][j] = 1; \n                }\n            }else{\n                result[i][j] = Math.max(i &gt; 0 ? result[i-1][j]:0,j &gt; 0 ?result[i][j-1]:0)\n            }\n        }\n    }\n    maxValue = result[result.length-1][result[0].length-1];\n    log(&apos;result -&gt;&apos;,result);\n    log(&apos;maxValue -&gt;&apos;,maxValue);\n}\n\n\ncomputingTheLongestSubsequence(&apos;fish&apos;,&apos;fosh&apos;);\ncomputingTheLongestSubsequence(&apos;fort&apos;,&apos;fosh&apos;);\n</code></pre>","thumbnail":"/images/算法/bg.jpg","categories":[],"tags":[{"name":"动态规划","path":"api/tags/动态规划.json"},{"name":"最长公共子串","path":"api/tags/最长公共子串.json"},{"name":"最长公共子序列","path":"api/tags/最长公共子序列.json"}]}