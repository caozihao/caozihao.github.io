{"title":"贪婪算法之近似算法（广播集合覆盖问题）","slug":"贪婪算法之近似算法（广播集合覆盖问题）","date":"2018-12-26T02:16:57.000Z","updated":"2018-12-26T12:56:27.139Z","comments":true,"excerpt":"","content":"<h4 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h4><ul>\n<li><p>贪婪算法(贪心算法)是指在对问题进行求解时，在每一步选择中都采取最好或者最优(即最有利)的选择，从而希望能够导致结果是最好或者最优的算法。</p>\n</li>\n<li><p>贪婪算法所得到的结果往往不是最优的结果(有时候会是最优解)，但是都是相对近似(接近)最优解的结果：</p>\n<ul>\n<li><p>贪婪算法并没有固定的算法解决框架，算法的关键是贪婪策略的选择，根据不同的问题选择不同的策略。</p>\n</li>\n<li><p>必须注意的是策略的选择必须具备无后效性，即某个状态的选择不会影响到之前的状态，只与当前状态有关，所以对采用的贪婪的策略一定要仔细分析其是否满足无后效性。</p>\n</li>\n<li><p>广度优先、狄克斯特拉算法，近似算法,动态规划,只是在其问题策略的选择上，刚好可以得到最优解。</p>\n</li>\n</ul>\n</li>\n<li><p>判断近似算法的优劣标准如下:</p>\n<ul>\n<li>速度有多快</li>\n<li>得到的近似解与最优解的接近程度</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"案例-广播集合覆盖问题\"><a href=\"#案例-广播集合覆盖问题\" class=\"headerlink\" title=\"案例:广播集合覆盖问题\"></a>案例:广播集合覆盖问题</h4><pre><code>const log = console.log.bind(this);\nconst test = ()=&gt;{\n    let states = {};\n    states[&apos;kone&apos;] = [&apos;id&apos;,&apos;nv&apos;,&apos;ut&apos;]\n    states[&apos;ktwo&apos;] = [&apos;wa&apos;,&apos;id&apos;,&apos;mt&apos;]\n    states[&apos;kthree&apos;] = [&apos;or&apos;,&apos;nv&apos;,&apos;ca&apos;]\n    states[&apos;kfour&apos;] = [&apos;nv&apos;,&apos;ut&apos;]\n    states[&apos;kfive&apos;] = [&apos;ca&apos;,&apos;az&apos;]\n\n    let statesNeeded = [&apos;id&apos;,&apos;nv&apos;,&apos;ut&apos;,&apos;wa&apos;,&apos;ca&apos;,&apos;mt&apos;,&apos;or&apos;,&apos;az&apos;];\n    let bestStation = [];\n    let statesCovered = [];//所有未覆盖的州\n    let couvered = [];//包含当前光比太覆盖一系列未覆盖的州\n    let finalStation = [];//最后的集合\n\n    while(statesNeeded.length){\n          statesCovered = [];\n          bestStation = [];\n          for(let state in states){\n              couvered = getTheRepeatArr(states[state],statesNeeded);\n              log(&apos;couvered -&gt;&apos;,couvered);\n              log(&apos;statesCovered -&gt;&apos;,statesCovered);\n              //判断未覆盖州中取最大的\n              if(couvered.length &gt; statesCovered.length){\n                  bestStation = state;\n                  statesCovered = couvered;\n              }\n          }\n        log(&apos;statesCovered -&gt;&apos;,statesCovered);\n        statesNeeded = removeTheRepeatArr(statesNeeded,statesCovered)\n        log(&apos;statesNeeded -&gt;&apos;,statesNeeded);\n        log(&apos;bestStation -&gt;&apos;,bestStation);\n        log(&apos;--------------&gt;&apos;);\n        finalStation.push(bestStation);\n      }\n    return finalStation;\n}\n\n    //获得重复的数组元素\n    const getTheRepeatArr = (arr1,arr2)=&gt;{\n        let obj = {};\n        let repeatArr = [];\n        for(let item of arr1){\n            obj[item] = 1;\n        }\n        for(let item of arr2){\n            if(obj[item]){\n                obj[item] = 2;\n                repeatArr.push(item);\n            }else{\n                obj[item] = 1;\n            }\n        }\n        return repeatArr;\n    }\n\n    //除去bigArr中的repeatArr中的元素\n    const removeTheRepeatArr = (bigArr,repeatArr)=&gt;{\n        let obj = {};\n        for(let item of repeatArr){\n            obj[item] = 1;\n        }\n\n        for(let i=0;i &lt; bigArr.length;i++){\n            if(obj[bigArr[i]]){\n                bigArr.splice(i,1);\n                i--;\n            }\n        }\n        return bigArr;\n    }\n\n\n    // let arr1 = [&apos;id&apos;,&apos;nv&apos;,&apos;ut&apos;,&apos;wa&apos;,&apos;ca&apos;];\n    // let arr2 = [&apos;id&apos;,&apos;nv&apos;,&apos;ut&apos;,&apos;mt&apos;,&apos;or&apos;,&apos;az&apos;];\n    // let result = removeTheRepeatArr(arr2,arr1);\n    // console.log(&apos;result -&gt;&apos;,result);\n    let result = test();\n    log(&apos;result -&gt;&apos;,result)\n</code></pre>","thumbnail":"/images/算法/bg.jpg","categories":[],"tags":[{"name":"贪婪算法","path":"api/tags/贪婪算法.json"}]}